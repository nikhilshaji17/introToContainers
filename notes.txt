Containers used to be called Linux Jails.

They are essentially 3 linux features taped together. 
1. Jailed processes
2. Control groups
3. Namespaces

We will jail a process, keep it resources to itself, and adding it to a C group.

Why containers:
Earlier, you had to run your code directly on your own server. This means you would have
  to take care of the OS and the hardware itself, including who can access the servers, the
  temperature of the room, power thats served to the servers etc.

  This means you would have to buy servers, then pay someone to take care of them, or take
  care of them yourself.

The next step was virtual machines, we can now take our server, and split it into virtual 
  machines, to run multiple applications

Now, you don't need to keep buying new servers for new applications. However, you still need to:
  a. Security patch your own servers
  b. Manage your own OS

Containers take the concept of virtual machines, but they avoid the need to keep duplicating
  operating systems for each virtual machines. So they are lighter

chroot:
  A command that allows you to "change root" of a process. This makes it such that the process
    now thinks that it is root, and cannot access anything before it. (Jailed process)


docker ps = Tells you which containers are running.

docker run -it --name docker-host --rm --privileged ubuntu:jammy

run = to run the container

-it = to make it interactive and not run in the background

--name docker-host = to give it a recognizable name

--rm = throw away all the information about this container once we're done.

--privileged = to give it root privilege (not recommended, only for current situation)

ubuntu:jammy = the distribution and its version

ldd bin/bash:
  Tells you all the libraries that you need to bring with bash so that bash can actually run

This is useful when you need to find what all libraries you need to copy into your new
  container.

Not only do we copy ls, or cat, from bin/ls or bin/cat, we also
  need the libraries they depend on, so we use ldd to find the libraries,
  and place them in lib and lib64

Although using jailed processes prevents multiple users from accessing each 
  other file systems, a user can still see what all processes are running
  throughout the system by using ps aux, and kill them if required.

Namespaces:
By using namespaces, a jailed process cannot see what other processes are running

We create the namespace using the keyword unshare. unshare creates a new isolated namespace from its parent

So what have we done so far:
chroot => Now the process thinks it's the root process
unshare => Now the process does not have access to other processes

But what if a chrooted and unshared process is manipulated such that it uses 100 percent
  of the resources of the server? Other users can no longer use this any more.

